
```{r load_packages, include = FALSE}
library(mosaic)
library(dplyr)
library(tidyverse)
library(ggplot2)
```

# The Seldonian Algorithm {#chap-2}

Chapter \@ref(intro) introduced the problem of algorithmic bias, discussed existing statistical definitions of fairness both in regression and classification settings, and finally, highlighted  fairness conflicts that can arise in certain settings. Of important note is that there are a plethora of fairness definitions that have been developed in statistical machine learning, many of which have been shown to be incompatible in ways similar to the illustration in Appendix \@ref(appendix-a). In any effort to enforce fairness on machine learning models, a critical first step is to define what fairness means in the specific context [@thomas2020housetestimony]. This responsibility falls on domain experts, social scientists, and regulators. Once there is consensus on that, machine learning researchers can work to develop appropriate algorithms that enforce the chosen definition of fairness. The Seldonian framework, introduced in this chapter, offers one such way to place probabilistic fairness constraints on traditional algorithms. However, because Seldonian algorithms place constraints on traditional machine learning (ML) algorithms, an initial in-depth understanding of the standard approach is key. Section \@ref(standardml) discusses the typical ML approach before diving into the Seldonian framework later in Section \@ref(seldonian). 

## The Standard Machine Learning Approach {#standardml}

When designing a machine learning algorithm, the first step is to mathematically define what the algorithm should do, in other words, the goal of the algorithm [@thomas2019supplementary]. At an abstract level, this goal is identical for all machine learning problems: find a solution $\theta^*$, within some feasible set $\Theta$, that maximizes some objective function $f: \Theta \rightarrow \textbf{R}$, where $\textbf{R}$ is the set of real numbers. Precisely, the goal of the algorithm is to search for an optimal solution  

$$\theta^* \in \underset{\theta \in \Theta}{\text{ arg max }} f(\theta).$$

For example, let $X$ and $Y$ be dependent real-valued random variables in a regression setting with the goal of estimating $Y$ given $X$. In this setting, $\Theta$ is the set of feasible functions that model the relationship between $X$ and $Y$. Feasible functions are of the form $\theta(X) = \beta_0 + \beta_1X = \hat{Y}$. Each function $\theta \in \Theta$ takes a real number as input and produces a real number as output; therefore, $\theta : \textbf{R} \rightarrow \textbf{R}$. A reasonable objective function would then be the negative mean squared error (MSE):

$$f(\theta):=-E[(\theta(X) - Y)^2].$$

In this case, minimizing MSE is equivalent to maximizing -MSE, defining the goal of the regression algorithm as finding the solution with the least average error. Note that the true value of $f(\theta)$ is unknown and can only be estimated from the data [@thomas2019preventing]. For a sample with $n$ observations, that is, $(x_i, y_i) \text{ for } i = 1,2,...,n$, the objective function can be estimated by:

$$\hat{f(\theta)}= -\frac{1}{n} \sum_{i=1}^{n}(\theta(x_i) - y_i)^2.$$
However, defining objective functions in this way can sometimes lead to undesirable behavior as illustrated in Section \@ref(standardlimitations).

### Limitations of the Standard Approach {#standardlimitations}

Consider a linear regression example to predict the qualifications of job applicants based on information on their resumes. Let $G$ encode the gender of each applicant, with $G=0$ if the applicant is female and $G=1$ if the applicant is male. Let $X$ encode a summary measure of an applicant's qualification based on information on their resume -- a simple example would be a measure of how many job-relevant key words appear on their resume. Let $Y$ encode their actual qualification for the job as determined by their observed performance. 

If this linear regression estimator is designed to be used to filter which resumes submitted to a company will be forwarded for human review, it is worthwhile to ensure that the algorithm does not produce racist or sexist behavior. Drawing from definitions in Chapter \@ref(fairnessdefinitions), it might be less important to ensure that the algorithm, on average, has the same predictions for applicants of both genders because the distribution of qualifications may be different for both genders. However, of more concern is whether the algorithm, on average, predicts too high for one gender and too low for the other gender. 

Suppose that the data has the following distribution: $Y$ ~ $N(1,1)$ if $G = 0$ and $Y$ ~ $N(-1,1)$ if $G = 1$, that is, $Y$ is a normal variable $N(\mu, \sigma)$ with different means $\mu$ for different genders but with the same standard deviation $\sigma$ for both genders. Further define $X$ ~ $N(Y,1)$, that is, an applicant's resume quality is equal to their true qualification plus some random noise. Figure \@ref(fig:fig1) displays a scatterplot of 1000 such data points, 500 from each gender. The black solid line is the least squares fit on this data using a gender-blind model. 


```{r fig1, fig.align='center', fig.cap="Least Squares Fit on Synthetic Data Drawn from Different Distributions", warning = FALSE, message = FALSE, fig.width = 4.5, fig.height = 3, echo = FALSE}
# set seed for reproducibility 
set.seed(123)

# generate synthetic data for both male and female applicants
female <- rnorm(500, mean = 1, sd = 1)
male <- rnorm(500, mean = -1, sd = 1)
gender <- c(rep(0,500), rep(1,500))

# create the data set
y <- union(female, male)
x <- rnorm(1000, mean = y, sd = 1)
data <- cbind(y, x, gender)
data <- data %>%
  as.data.frame(data)

# fit least squares line
ggplot(data = data, mapping = aes(x = x, y = y)) +
  geom_point(aes(color = as.factor(gender)), alpha = 0.8) +
  geom_smooth(
    method = "lm",
    aes(color = as.factor(gender)),
    se = F,
    size = 2
  ) +
  geom_smooth(
    method = "lm",
    formula = y ~ x,
    color = 'black',
    se = F
  ) +
  labs(color = "Gender (G)",
       title = "Least Squares Fit on Synthetic Data") +
  theme_minimal() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) 
```

```{r, echo = FALSE}
# set seed for reproducibility
set.seed(123)

# obtain the least squares linear model
model <- lm(y ~ x, data = data)

# obtain the model predictions 
preds <- predict(model, newdata = data)

# add the error into the data set
data <- data %>%
  mutate(error = preds - data$y)

# compute average error per gender 
diff <- data %>%
  group_by(gender) %>%
  summarise(average = mean(error)) 

# obtain the discrimination statistic
d <- diff$average[1] - diff$average[2]
```

The least squares fit on Figure \@ref(fig:fig1) is impartial to an observation's gender with an objective to make the most accurate predictions. While it may be expected that impartiality would produce fair results, observe that the linear model tends to over-predict if $G = 1$ and under-predict if $G=0$, on the contrary, producing discriminatory behavior. In fact, by defining a discrimination statistic, $d(\theta)$, as defined below in line with the specified fairness definition, the discrimination statistic for the synthetic data set in Figure \@ref(fig:fig1) can be shown to be `r d`, suggesting that the model predictions are in favor of $G = 1$:
 

$$ d(\theta) =  E[\hat{Y}-Y|G = 0 ] - E[\hat{Y}-Y|G = 1 ]. $$


In crucial applications such as hiring, this is concerning and highlights how linear regression algorithms designed using the standard approach can result in predictions of applicant performance that systematically discriminate against a demographic group.


### Potential Remedies

As illustrated in Section \@ref(standardlimitations) above, machine learning algorithms that use the standard approach may produce undesirable behavior. In an attempt to remedy this problem, a number of approaches can be taken. One potential remedy is to identify the root cause of the undesirable behavior such as class imbalance in the training data, bias in the data set, the choice of linear estimator, the model's blindness to the demographic group, or insufficient data, to name a few [@thomas2019supplementary]. For instance, in the example set up in Section \@ref(standardlimitations) and displayed in Figure \@ref(fig:fig1), the root cause of the discriminatory behavior when using ordinary least squares linear regression was the fact that the objective function was designed to minimize MSE, which was at odds with minimizing the discrimination statistic. However, even though it might be possible to determine and correct the root cause of the undesirable behavior, doing so can be difficult, error-prone, and require extensive data analysis, rendering the central goal of machine learning algorithms, which are designed to automate and make decision-making processes simpler, obsolete.

Assuming that the problem is with the objective function and provided that detailed knowledge of the problem is available, hard constraints may be placed on the objective function, for example, requiring that MSE is minimized only on the set of solutions with a discrimination value $d(\theta)$ less than some value $\epsilon$ [@thomas2019supplementary]. Additionally, rather than placing hard constraints on the set of solutions, soft constraints that penalize undesirable behavior may also be placed on $f$, the objective function [@boyd2004convex]. Although such penalty functions can be effective, they require a careful choice of the value of the parameter $\lambda$ that places relative importance on the objective function and the constraint. For the linear regression example, the new objective function with a soft constraint would now be:

$$f(\theta) = - MSE (\theta) - \lambda d(\theta).$$
Observe that as $\lambda$ increases, MSE increases and the discrimination statistic decreases. Cross-validation techniques can be employed to find optimal values for $\lambda$. Other remedies include maximizing multiple objective functions or allowing constraints on the probability that a solution with undesirable behavior will be returned, both of which may require detailed knowledge of the application problem and underlying distribution of the data [@thomas2019supplementary]. 

In principle, there might be definitions of $\Theta$ or $f$ that prevent the algorithm from converging on solutions that exhibit undesirable behavior [@thomas2019preventing]. However, in practice and as explained, this might require extensive domain expertise and data analysis in order to properly balance the relative importance of the objective function and the constraints, which can be at odds with each other. These techniques may also require knowledge of the probability distribution from which the data is sampled, which is not always available and limits applications to parametric statistics.

A Seldonian algorithm, thus, addresses this problem precisely by allowing probabilistic constraints on undesirable behavior to be placed more easily without detailed knowledge of the specific problem or the distribution of the data, shifting the burden from the domain experts who use these tools to the experts in ML and statistics [@thomas2019preventing]. It's named after Isaac Asimov’s fictional character, Hari Seldon ^[In the fictional book, Hari Seldon was a resident of a fictional planet where he develops psycho-history, an algorithmic science that allows him to predict the future in probabilistic terms.] [@asimov1994forward]. 

## The Seldonian Framework {#seldonian}

The first step of the Seldonian framework is to define mathematically the goal of the algorithm design [@thomas2019supplementary]. Define $\textbf{D}$ as the set of all possible inputs (data sets) to the algorithm. $\Theta$, as previously defined, is the set of all possible outputs (solutions) of the algorithm. Each solution is referred to as $\theta \in \Theta$. $D$ is the data set (input) given to the algorithm and is the only random variable. Now, $a: \textbf{D} \rightarrow \Theta$ is a machine learning algorithm which takes in a data set $D \in \textbf{D}$ as an input and returns a solution $\theta \in \Theta$ as an output. $\textbf{A}$ is the set of all possible machine learning algorithms. Synthesizing this, $f: \textbf{A} \rightarrow \textbf{R}$ is the objective function of the algorithm design, where $f(a) \in \textbf{R}$ is a real-valued measure of the utility of the algorithm, such as the value of the objective function for the solution returned by this algorithm. This objective function is optimized -- either minimized or maximized -- to select a desired machine learning algorithm from the set $\textbf{A}$.

Contrary to the standard ML approach, however, $n$ behavioral constraints can then be specified [@thomas2019supplementary]. Specifically, $(g_i, \delta_i)_{i=1}^{n}$ can be defined as a set of $n$ constraints, each of which contains a constraint function $g_i: \Theta \rightarrow \textbf{R}$ and a desired confidence level $\delta_i$. The constraint function takes in a solution returned from the chosen machine learning algorithm as an input and returns a real value encoding the "fairness" of the algorithm according to the fairness definition defined by the function. $(g_i, \delta_i)_{i=1}^{n}$ is defined such that:

- The $i^{th}$ constraint function measures an undesirable behavior. Specifically, $\theta \in \Theta$ produces undesirable behavior if and only if $g_i(\theta) > 0$. This is to ensure that undesirable behavior is defined in a mathematically tractable way such as how the discrimination statistic $d(\theta)$ was defined in Section \@ref(standardlimitations).

- The $i^{th}$ confidence level specifies the maximum probability that an algorithm can return a solution $\theta$ where $g_i(\theta) > 0$. In other words, $1 - \delta_i$ specifies the minimum probability that desirable behavior ($g_i(\theta) \leq 0$) is met. Smaller values of $\delta_i$ are preferred. 

In summary, a Seldonian algorithm ensures that for all $i \in \{1,2,\ldots,n\}$:

$$P(g_i(a(D)) \leq 0) \geq 1 - \delta_i.$$
Section \@ref(sop) goes into further detail about the Seldonian framework and how these probabilistic behavioral constraints are guaranteed.

### The Seldonian Optimization Problem {#sop}

As detailed, the Seldonian framework is different from current potential remedies of undesirable behavior because it defines a search over a possible set of algorithms with constraints, rather than over a possible set of solutions. This means that the constraints require that the probability that a machine learning algorithm returns an unsafe solution be bounded by some desired level of confidence, rather than the probability that a solution itself is unsafe. In summary, a Seldonian optimization problem (SOP) can be written as [@thomas2019preventing]:

$$\underset{a \in \textbf{A}}{\text{ arg max }} f(a)$$

$$\text{s.t. } \forall \text{ } i \in \{1, 2, \ldots, n\} \text{, } P(g_i(a(D)) \leq 0) \geq 1 - \delta_i.$$

A Seldonian algorithm $a$, thus, returns, with high probability, a solution that guarantees desirable behavior. If one were to apply machine algorithm $a$ to obtain a solution from a large number of different data sets $D$ drawn from the same distribution, then it would be expected that at most $100\delta_i \%$ solutions (models) would produce undesirable behavior. 

Taking the previous regression example and turning it into a Seldonian optimization problem using the discrimination statistic in Section \@ref(standardlimitations), $f$ would still be an objective function like the MSE, $\Theta$ would still be the set of all possible linear models, and $D$ would be the data set as described. There would be 1 behavioral constraint, $g_1(a(D)) = |d(a(D))| - \epsilon$, to guarantee with probability at least $1-\delta_1$, that the absolute value of the discrimination statistic would be at most $\epsilon$, where $\epsilon$ and $\delta_1$ are chosen based on the specific application. Note that the user of the machine learning algorithm need not perform data analysis to determine whether $g_1(\theta) \leq 0$ for a particular solution $\theta \in \Theta$ returned. The burden is shifted to the computation algorithm to determine this with some desired level of probability. 

```{r seldonian1, fig.cap="Overview of the Seldonian Framework (P. S. Thomas et al., 2019a)", out.width = '100%', echo=FALSE, fig.scap="Overview of the Seldonian Framework"}
include_graphics(path = "figures/seldonian1.png")
```

Figure \@ref(fig:seldonian1) illustrates how this is achieved at a high level. A Seldonian algorithm takes in $n$ behavioral constraints $(g_i,\delta_i)_{i=1}^n$ and a data set $D$ as the inputs and returns either a solution (model) $\theta$ or $NSF$, which means "No Solution Found". That is, no algorithm was found that returned a model which satisfied the behavioral constraints with the desired probability. First, the data $D$ is partitioned into 2 sets $D_1$ and $D_2$ that essentially serve as train and test sets, respectively. $D_1$ is then passed through the candidate selection mechanism, which performs a search over algorithms to settle on a candidate solution $\theta_c$. $\theta_c$ is selected not only so that it optimizes the primary objective function $f$, but also so that it is predicted to pass the subsequent safety test. $D_2$ is then passed through the safety test to check whether $\theta_c$ indeed satisfies the $n$ behavioral constraints with the desired confidence for each, that is $P(g_i(\theta_c) \leq 0) \geq 1 - \delta_i$ for each constraint $i \in \{ 1,2, \ldots, n \}$. If so, $\theta_c$ is returned as the desired solution, and otherwise, NSF [@thomas2019preventing]. 

Note that finding exact confidence intervals may be impractical and require large amounts of data. Quasi-Seldonian algorithms, thus, are an extension of this idea that rely on standard statistical tools to transform sample statistics computed from $D$ into approximate bounds on the probability of undesirable behavior [@thomas2019preventing]. Section \@ref(qsa) discusses the statistical framework employed to achieve this. 

### Quasi-Seldonian Algorithms {#qsa}

https://aisafety.cs.umass.edu/tutorial3.html

Introduce quasi-seldonian algorithms to show how we would actually compute and execute this. Good place to talk about some of the key steps/ functions defined in the section above in mathematical detail.

Finish by Monday :)

## Toy Example: A Seldonian Regression Algorithm

Walk through key parts of the jupyter notebook

Finish by Tuesday evening :)

## Random Notes (Delete When Done):

Submit on Wednesday/ Thursday!

Need another source for this section?

Change colors on image.

Assign equations labels in Chapter 1 & 2 like below? 

Review notes to fill in missing pieces.

\begin{equation}
\label{discstat}
d(\theta) =  E[\hat{Y}-Y|G = 0 ] - E[\hat{Y}-Y|G = 1 ].
\end{equation}